=Miscellaneous features=


==Multi-user collaborative drawing application==

To turn our drawing application to a multi user one, we need to
refactor some parts. In particular, we need to be able to handle
separately different drawings. To do this, we will turn all global
variable, like the bus, in local ones.

===Split application into multiple files===

When an application grows, it start being usefull to split it in
multiple files. For sake of example, we will split graffiti into 4
files.

* {{{common.ml}}} wich will be part of both client and server,
containing shared types and declarations
* {{{client.ml}}} client only part of the application
* {{{server.ml}}} server only part of the application
* {{{graffiti.eliom}}} the only part where we need to include both client and server code

===={{{common.ml}}}====

It contains what was in {{{ {shared{ .. }} }}}
<<code language="ocaml"|type messages = (string * int * (int * int) * (int * int)) deriving (Json)

let width = 700
let height = 400>>

===={{{client.ml}}}====

It is almost the same code as what was enclosed in {{{ {client{ ... }} }}}
with the difference that what was previously in
{{{ Eliom_services.onload {{ }} }}} is now in the function, {{{ launch_client_canvas }}}.

<<code language="ocaml"|open Common open
Event_arrows

let draw ctx (color, size, (x1, y1), (x2, y2)) =
  ctx##strokeStyle <- (Js.string color);
  ctx##lineWidth <- float size;
  ctx##beginPath();
  ctx##moveTo(float x1, float y1);
  ctx##lineTo(float x2, float y2);
  ctx##stroke() >>

Since we want to be able to change page without restarting the
application, we can not add the canvas and the widgets directly to the
document as it would then stay at the botom of the page after page
change. We now append it to an element of the page that is newly
generated: {{{canvas_box}}}.

<<code language="ocaml"|let launch_client_canvas bus imageservice canvas_box =
  let canvas = Dom_html.createCanvas Dom_html.document in
  let ctx = canvas##getContext (Dom_html._2d_) in
  canvas##width <- width; canvas##height <- height;
  ctx##lineCap <- Js.string "round";

  (* The initial image: *)
  let img = Dom_html.createImg Dom_html.document in
  img##alt <- Js.string "canvas";
  img##src <- Js.string (Eliom_output.Xhtml5.make_string_uri ~service:imageservice ());
  img##onload <- Dom_html.handler (fun ev -> ctx##drawImage(img, 0., 0.); Js._false);

  Dom.appendChild canvas_box canvas;

  (* Size of the brush *)
  let slider = jsnew Goog.Ui.slider(Js.null) in
  slider##setMinimum(1.);
  slider##setMaximum(80.);
  slider##setValue(10.);
  slider##setMoveToPointEnabled(Js._true);
  slider##render(Js.some canvas_box);
  
  (* The color palette: *)
  let pSmall = 
    jsnew Goog.Ui.hsvPalette(Js.null, Js.null,
                             Js.some (Js.string "goog-hsv-palette-sm"))
  in
  pSmall##render(Js.some canvas_box);

  let x = ref 0 and y = ref 0 in
  let set_coord ev =
    let x0, y0 = Dom_html.elementClientPosition canvas in
    x := ev##clientX - x0; y := ev##clientY - y0 in
  let compute_line ev = 
    let oldx = !x and oldy = !y in
    set_coord ev;
    let color = Js.to_string (pSmall##getColor()) in
    let size = int_of_float (Js.to_float (slider##getValue())) in
    (color, size, (oldx, oldy), (!x, !y))
  in
  let line ev =
    let v = compute_line ev in
    let _ = Eliom_client_bus.write bus v in
    draw ctx v
  in
  let _ = Lwt_stream.iter (draw ctx) (Eliom_client_bus.stream bus) in
  ignore (run (mousedowns canvas
		 (arr (fun ev -> set_coord ev; line ev)
			      ~>>> first [mousemoves Dom_html.document (arr line);
					 mouseup Dom_html.document ~>>> (arr line)])) ())
>>

===={{{server.ml}}}====

It contains almost all the server part of the code.
<<code language="ocaml"|open XHTML5.M
open Common

module My_appl =
  Eliom_output.Eliom_appl (
    struct
      let application_name = "graffiti"
      let params =
	{ Eliom_output.default_appl_params with
	  
          Eliom_output.ap_headers_before =
            [
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/graffiti.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/common.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/hsvpalette.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/slider.css")
                ();
              XHTML5.M.script
                ~a:[XHTML5.M.a_src (XHTML5.M.uri_of_string "http://closure-library.googlecode.com/svn/trunk/closure/goog/base.js")
                   ] (XHTML5.M.pcdata "");
              XHTML5.M.script
                ~a:[XHTML5.M.a_src (XHTML5.M.uri_of_string "./graffiti_req.js")
                   ] (XHTML5.M.pcdata "");
            ];
	}
    end)
let rgb_from_string color = (* color is in format "#rrggbb" *)
  let get_color i = (float_of_string ("0x"^(String.sub color (1+2*i) 2))) /. 255. in
  try get_color 0, get_color 1, get_color 2 with | _ -> 0.,0.,0.
>>

The main difference is that the bus and the {{{image_string}}} are now local.
<<code language="ocaml"|let launch_server_canvas () =
  let bus = Eliom_bus.create Json.t<messages> in
  
  let draw_server, image_string =
    let surface = Cairo.image_surface_create Cairo.FORMAT_ARGB32 ~width ~height in
    let ctx = Cairo.create surface in
    ((fun ((color : string), size, (x1, y1), (x2, y2)) ->

      (* Set thickness of brush *)
      Cairo.set_line_width ctx (float size) ;
      Cairo.set_line_join ctx Cairo.LINE_JOIN_ROUND ;
      Cairo.set_line_cap ctx Cairo.LINE_CAP_ROUND ;
      let red, green, blue =  rgb_from_string color in
      Cairo.set_source_rgb ctx ~red ~green ~blue ;

      Cairo.move_to ctx (float x1) (float y1) ;
      Cairo.line_to ctx (float x2) (float y2) ;
      Cairo.close_path ctx ;
      
      (* Apply the ink *)
      Cairo.stroke ctx ;
     ),
     (fun () ->
       let b = Buffer.create 10000 in
       (* Output a PNG in a string *)
       Cairo_png.surface_write_to_stream surface (Buffer.add_string b);
       Buffer.contents b
     ))
  in
  let _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus) in
  bus,image_string
>>

The main page now does launch the application. It only contains a
formulary to choose to wich drawing you want to go. The application is
launched by the {{{multigraffiti_service}}} service. It is registered
in {{{graffiti.eliom}}}.

<<code language="ocaml"|let multigraffiti_service = Eliom_services.service ~path:["multigraffiti"]
  ~get_params:(Eliom_parameters.string "name") ()

let choose_drawing_form () =
  My_appl.get_form ~service:multigraffiti_service
    (fun (name) ->
      [p [pcdata "drawing name: ";
          Eliom_output.Xhtml5.string_input ~input_type:`Text ~name ();
          br ();
          Eliom_output.Xhtml5.string_input ~input_type:`Submit ~value:"Go" ()
         ]])

let _ = Eliom_output.Xhtml5.register_service
  ~path:[""] ~get_params:Eliom_parameters.unit
  ( fun () () ->
    let v = [h1 [pcdata "Welcome to Multigraffiti"];
	     choose_drawing_form ()] in
    Lwt.return (html (head (title (pcdata "multigraffiti")) []) (body v)))
>>

===={{{graffiti.eliom}}}====

Here is the code that mix client and server parts.

We first open the corresponding modules for each parts of the
application.

<<code language="ocaml"|{shared{
  open XHTML5.M
  open Common
}}
{client{
  open Client
}}
open Server
>>

<<code language="ocaml"|let graffiti_info = Hashtbl.create 0

let include_canvas (name:string) (canvas_box:[ Xhtml5types.div ] XHTML5.M.elt) =

  (* create a new bus and image_string function only if it did not exists *)
  let bus,image_string =
    try
      Hashtbl.find graffiti_info name
    with
      | Not_found ->
	let bus,imageservice = launch_server_canvas () in
	Hashtbl.add graffiti_info name (bus,imageservice);
	(bus,imageservice)
  in

  let imageservice =
    Eliom_output.Text.register_coservice'
      ~timeout:10.
      (* the service is available fo 10 seconds only, but it is long
	 enouth for the browser to do its request. *)
      ~get_params:Eliom_parameters.unit
      (fun () () -> Lwt.return (image_string (), "image/png"))
  in

  Eliom_services.onload
    {{
      launch_client_canvas %bus %imageservice %canvas_box
    }}
>>

{{{imageservice}}} is now a new service each time the page is loaded
as we need to be able to request several times the same image (if we
go to the same page several times during the life of the application),
but its content can change. If we use the same get request each time,
the browser use its cache and show the same contents. By using a
coservice, we can force it to reload the image.

And we finally register the service.

<<code language="ocaml"|let () = My_appl.register ~service:multigraffiti_service
  ( fun name () ->
    (* the page element in wich we will include the canvas *)
    let canvas_box = div [] in
    include_canvas name canvas_box;
    Lwt.return [
      h1 [pcdata name];
      choose_drawing_form ();
      canvas_box;] )
>>

==== {{{Makefile}}} ====

We now need to change the makefile to addapt to these changes. First,
we add the files to the list of files wich need to be compiled. The
order is important, the makefile does not resolve dependencies.
<<code language="Makefile"|
SERVERFILES := common.ml server.ml ${PROJECTNAME}.eliom
CLIENTFILES := common.ml client.ml ${PROJECTNAME}.eliom
>>

Since we are using the deriving syntax in {{{.ml}}} files, we need to
add its package. It was not usefull for compilation of
{{{graffiti.eliom}}} file as the syntax of eliom files depends on the
package {{{ocsigen.deriving.syntax}}}.
<<code language="Makefile"|
SERVERLIB := -package ocsigen.deriving.syntax -package cairo
CLIENTLIB := -package ocsigen.deriving.syntax -package oclosure -package js_of_ocaml.
>>
It is also needed to add {{{-syntax camlp4o \}}} to commands that doesn't have it.

Download the current versions of the files:
[[manual/dev/files/multigraffiti_v1/graffiti.eliom|graffiti.eliom]]
[[manual/dev/files/multigraffiti_v1/common.ml|common.ml]]
[[manual/dev/files/multigraffiti_v1/client.ml|client.ml]]
[[manual/dev/files/multigraffiti_v1/server.ml|server.ml]]
[[manual/dev/files/multigraffiti_v1/Makefile|Makefile]]

===Type safe database requests using Macaque===

In this section, we will implement our database access function
using the //Macaque// library, that allows~ ...

===Saving favorite pictures===
bla\\bla\\bla\\bla\\

<<code language="ocaml"|
>>

<<div class="encadre"|====  ====
>>

===Connection with external accounts===
<<div class="concepts"|openID>>
bla\\bla\\bla\\bla\\

<<code language="ocaml"|
>>

<<div class="encadre"|====  ====
>>

===listening music===
<<div class="concepts"|Persistence of the client application>>
bla\\bla\\bla\\bla\\

<<code language="ocaml"|
>>

<<div class="encadre"|====  ====
>>


===???===
<<div class="concepts"|Other features: Atom ...\\
Client side service calls ...\\
Client side forms ...\\
**LWT** -> où ????????????,>>
bla\\bla\\bla\\bla\\

<<code language="ocaml"|
>>

<<div class="encadre"|====  ====
>>
